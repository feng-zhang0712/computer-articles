# 树

树结构是一类重要的非线性数据结构。直观来看，树是以分支关系定义的层次结构。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树来形象表示。树在计算机领域中也得到广泛应用，尤以二叉树最为常用。如在操作系统中，用树来表示文件目录的组织结构；在编译系统中，用树来表示源程序的语法结构；在数据库系统中，树结构也是信息的重要组织形式之一。

## 一、树的定义

### 1.1 树的定义

树（Tree）是 n（n=0）个结点的有限集，它或为空树（n=0）；或为非空树，对于非空树 T：

- 有且仅有一个称之为根的结点；
- 除根结点以外的其余结点可分为 m（m>0）个互不相交的有限集 $T_1$, $T_2$, ..., $T_m$， 其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。

例如，在下图中，（a）是只有一个根结点的树；（b）是有13个结点的树，其中 A 是根，其余结点分成3个互不相交的子集：$T_1$={B, E, F, K, L}，$T_2$={C, G}，$T_3$ = {D, H, I, J, M}。$T_1$、$T_2$ 和 $T_3$ 都是根 A 的子树，且本身也是一棵树。例如 $T_1$，其根为 B，其余结点分为两个互不相交的子集：$T_{11}$={E, K, L}，$T_{12}$={F}。$T_{11}$ 和 $T_{12}$ 都是 B 的子树。而 $T_{11}$ 中 E 是根，{K} 和 {L} 是 E 的两棵互不相交的子树，其本身又是只有一个根结点的树。

![树的示例](/assets/tree.png)

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了树的固有特性。树还可有其他的表示形式，如图5.2所示为图5.1(b)中树的各种表示。其中(a)是以嵌套集合(即是一些集合的集体，对于其中任何两个集合，或者不相交，或者一个包含另一个)的形式表示的；(b)是以广义表的形式表示的，根作为由子树森林组成的表的名字写在表的左边；(c)用的是凹入表示法(类似书的编目)。表示方法的多样化，正说明了树结构在日常生活中及计算机程序设计中的重要性。一般来说，分等级的分类方案都可用层次结构来表示，也就是说，都可由一个树结构来表示。

![树的其他3种表示法](/assets/tree-in-defination.png)

下面介绍树结构中的一些基本术语。

### 1.2 树的基本术语

- **结点**：树中的一个独立单元，包含一个数据元素及若干指向其子树的分支。如[树的定义部分示例图](#11-树的定义)中的A、B、C、D等。（下面术语中均以图为例来说明）
- **结点的度**：结点拥有的子树数称为结点的度。例如，A的度为3，C的度为1, F的度为0。
- **树的度**：树的度是树内各结点度的最大值。示例图所示的树的度为3。
- **叶子**：度为0的结点称为叶子或终端结点。结点K、L、F、G、M、I、J都是树的叶子。
- **非终端结点**：度不为0的结点称为非终端结点或分支结点。除根结点之外，非终端结点也称为内部结点。
- **双亲和孩子**：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。例如，B的双亲为A，B的孩子有E和F。
- **兄弟**：同一个双亲的孩子之间互称兄弟。例如，H、I和J互为兄弟。
- **祖先**：从根到该结点所经分支上的所有结点。例如，M的祖先为A、D和H。
- **子孙**：以某结点为根的子树中的任一结点都称为该结点的子孙。如B的子孙为E、K、L和F。
- **层次**：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。
- **堂兄弟**：双亲在同一层的结点互为堂兄弟。例如，结点 G与E、F、H、I、J互为堂兄弟。
- **树的深度**：树中结点的最大层次称为树的深度或高度。示例图所示的树的深度为4。
- **有序树和无序树**：如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为有序树，否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子。
- **森林**：是 m（m≥0）棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。

就逻辑结构而言，任何一棵树都是一个二元组 Tree=(root, F)。其中 root 是数据元素，称作树的根结点；F 是 m(m≥0)棵树的森林，F=($T_1$, $T_2$, ..., $T_n$)，其中 $T_i$=($r_i$, $F_i$) 称作根 root 的第 i 棵子树；当 m≠0 时，在树根和其子树森林之间存在下列关系：

$$RF = {<root, r_i>|i=1, 2, ..., m, m>0}$$

这个定义将有助于得到森林和树与二叉树之间转换的递归定义。


5.1.3 二叉树的定义
二叉树 ( Binary Tree)是n(n=0)个结点所构成的集合,它或为空树(n=0);或为非空树,
对于非空树T:
(1)有且仅有一个称之为根的结点;
(2)除根结点以外的其余结点分为两个互不相交的子集和T2,分别称为T的左子树和右子
树,且 和T本身又都是二叉树。
二叉树与树一样具有递归性质,二叉树与树的区别主要有以下两点:
(1)二叉树每个结点至多只有两棵子树(即二叉树中不存在度大于2的结点);
(2)二叉树的子树有左右之分,其次序不能任意颠倒。
延出
二叉树的递归定义表明二叉树或为空,或是由一个根结点加上两棵分别称为左子树和右子树
的、互不相交的二叉树组成。由于这两棵子树也是二叉树,则由二叉树的定义,它们也可以是空
树。由此,二叉树可以有5种基本形态,如图5.3所示。
(a)空二叉树
(b)仅有根结点的二叉树
(c)右子树为空的二叉树
(d)左、右子树均非空的二叉树
(e)左子树为空的二叉树
图 5.3 二叉树的5种基本形态
5.1.2 小节中引入的有关树的术语是都适用于二叉树。
县天
113

Page 122
114
数据结构(C语言版)(第2版)
5.2
案例引入。此菌极短
随着大数据时代的到来,如何采用有效的数据压缩技术,来节省数据文件的存储空间和网络
传输时间越来越引起人们的重视。
案例 5.1:数据压缩问题。
在数据通信、数据压缩问题中,需要将数据文件转换成二进制字符0、1组成的二进制串,
称之为编码。
假设待压缩的数据为“abcdabcdaaaaabbbdd”,文件中只包含a、b、c、d四种字符,如果采用
等长编码,每个字符编码取两位即可,表5.1(a)所示为一种等长编码方案。上述数据为18个字
符,其编码总长度为36位。但这并非最优的编码方案,因为每个字符出现的频率不同,如果在编
码时考虑字符出现的频率,使频率高的字符采用尽可能短的编码,频率低的字符采用稍长的编码,
来构造一种不等长编码,则会获得更好的空间效率,这也是文件压缩技术的核心思想。如表 5.1
(b)所示为一种不等长编码方案,采用这种编码方案时,其编码总长度为35位。但对于不等长编
码,如果设计得不合理,便会给解码带来困难。例如,对于如表5.1(c)所示的另一种不等长编
码方案,上述数据编码后为“00101111100101111100000010101111111”。但是,这样的编码数据无
法翻译,例如,传送过去的字符串中前4个字符的子串“0010”就可有不同的译法,或是“aba”,
或是“ac”。因此,若要设计长短不等的编码,必须满足一个条件:任何一个字符的编码都不是另
一个字符的编码的前缀。表5.1(b)所示的编码方案便满足这个条件。
那么如何设计有效的用于数据压缩的二进制编码呢?我们可以利用一种特殊的树结构一 -哈
夫曼树来设计。表5.1(b)所示的编码是以字符a、b、c、d在数据串“abcdabcdaaaaabbbdd”中
出现的次数7、5、2、4为权值,构造如图5.4所示的哈夫曼树,其4个叶子结点分别表示a、b、
c、d这4个字符,且约定左分支标记为0,右分支标记为1,则根结点到每个叶子结点路径上的0、
1序列即为相应字符的编码。由图5.4所得a、b、c、d的二进制编码分别为0、10、110 和 111。
有关哈夫曼树的构造及其编码设计的具体内容,将在5.7 节详细介绍。
表5.1
3种不同的编码方案
(a)等长编码方案
字符
(b)不等长编码方案1
编码
字符
编码
(c)不等长编码方案2
字符
编码
a
00
a
0
a
0
b
01
b
10
b
01
C
10
C
110
C
010
d
11
d
111
d
111
案例 5.2:利用二叉树求解表达式的值。
一般情况下,一个表达式由一个运算符和两个操作数构成,两个操作数之间有次序之分,并
且操作数本身也可以是表达式,这个结构类似于二叉树,因此可以利用二叉树来表示表达式。
以二叉树表示表达式的递归定义如下:
(1)若表达式为数或简单变量,则相应二叉树中仅有一个根结点,其数据域存放该表达
式信息;

Page 123
第5章树和二叉树
(2)若表达式为“第一操作数运算符 第二操作数”的形式,则相应的二叉树中以左子树表
示第一操作数,右子树表示第二操作数,根结点的数据域存放运算符(若为一元运算符,则左子
树为空),其中,操作数本身又为表达式。
如图 5.5 所示的二叉树表示表达式a+b*(c-d)-e/f。在二叉树中表达式中并无括号,但其结
构却有效地表达了其运算符间的运算次序。利用二叉树的遍历等操作,可实现表达式的求值运算,
有关内容将在5.8节详细介绍。
0
a
d
图5.4 哈夫曼树及编码示例
图5.5 表达式(a+b*(c-d)-e/f)的二叉树
5.3 树和二叉树的抽象数据类型定义
根据树的结构定义,加上树的一组基本操作就构成了树的抽象数据类型定义:
ADT Tree{
数据对象D:D是具有相同特性的数据元素的集合。
数据关系 R:若D为空集,则称为空树;
若D仅含一个数据元素,则为空集,否则R={H},H是如下二元关系:
(1)在D中存在唯一的称为根的数据元素 root,它在关系H下无前驱;
(2)若D-{root}≠,则存在D-{root}的一个划分D,D2,..., Dm(m>0),对任意j≠k(1≤j, k≤m)有
DjnDx = 4,且对任意的i(1≤i≤m),唯一存在数据元素x;∈D,有<root,xi>∈H;
(3)对应于D-{root}的划分,H-{<root,xi>,…,<root,x> =有唯一的一个划分 H1,H2,
Hm(m>0),对任意j≠k(1≤j, k≤m)有HgnHk=0,且对任意i(1≤i≤m),H是D上的二元关
系,(Di, {H})是一棵符合本定义的树,称为根 root 的子树。
seT TOA
基本操作 P:
InitTree(&T)
操作结果:构造空树T。
DestroyTree(&T)
初始条件:树存在。
操作结果:销毁树 T。
CreateTree (&T, definition) 01
初始条件:definition 给出树的定义。
操作结果:按definition 构造树 T。
ClearTree (&T)
初始条件:树存在。
操作结果:将树清为空树。
eerTyssaia POA
115

Page 124
116
数据结构(C语言版)(第2版)
TreeEmpty (T)
初始条件:树存在。
操作结果:若为空,则返回true,否则false。
TreeDepth (T)
初始条件:树存在。
操作结果:返回T的深度。
Root (T)
初始条件:树存在。
操作结果:返回T的根。
Value (T, cur_e)
初始条件:树存在,cur_e
ar_e是T中某个结点。
操作结果:返回cure的值。
Assign (T, cur_e,value)
初始条件:树存在,cure是T中某个结点。
操作结果:结点cure赋值为value。
Parent (T, cur_e);
初始条件:树T存在,cur_e是中某个结点。
操作结果:若 cur_e是T的非根结点,则返回它的双亲,否则函数值为“空”。
LeftChild(T,cur_e)
初始条件:树T存在,cur_e是中某个结点。
操作结果:若cure 是T的非叶子结点,则返回它的最左孩子,否则返回“空”。
RightSibling (T,cur_e)
初始条件:树T存在,cur_e是中某个结点。
操作结果:若 cur_e有右兄弟,则返回它的右兄弟,否则函数值为“空”。
InsertChild(&T,p,i,c)
8.2
初始条件:树存在,p指向T中某个结点,1≤i≤p所指结点的度+1,非空树c与不相交。
操作结果:插入c为T中p指结点的第i棵子树。
DeleteChild (&T, p,i)
初始条件:树T存在,p指向T中某个结点,1≤i≤p 指结点的度。
操作结果:删除T中所指结点的第i棵子树。
TraverseTree (T)
初始条件:树存在。
操作结果:按某种次序对T的每个结点访问一次。
} ADT Tree
二叉树的抽象数据类型定义如下:
ADT BinaryTree {
数据对象D:D是具有相同特性的数据元素的集合。
数据关系 R:
若 D=,则 R=0,称BinaryTree为空二叉树;
若D≠,则R={H},H是如下二元关系:
(1)在D中存在唯一的称为根的数据元素root,它在关系H下无前驱;
(2)若D-{root}=,则存在D-{root}={Dı, Dr},且D:ND=0;
(3)若D≠,则D中存在唯一的元素x1, <root,xi>∈H,且存在D上的关系HCH;若D ≠ $,
则 D. 中存在唯一的元素 x², <root, x->EH,且存在D上的关系H+CH;H={<root, xi>, <root,
Xr>, H｣, Hr};

Page 125
第5章树和二叉树
(4)(Dı, {H})是一棵符合本定义的二叉树,称为根的左子树,(Dr {H})是一棵符合本定义的二
叉树,称为根的右子树。
基本操作P:
InitBiTree(&T)
操作结果:构造空二叉树 T
DestroyBiTree(&T)
初始条件:二叉树T存在。
操作结果:销毁二叉树 T。
CreateBiTree(&T, definition)
初始条件;definition 给出二叉树T的定义。
操作结果:按definition 构造二叉树T。
ClearBiTree(&T)
初始条件:二叉树T存在。
操作结果:将二叉树清为空树。
BiTreeEmpty(T)
初始条件:二叉树存在。
操作结果:若为空二叉树,则返回true,否则false。
()味叉二
BiTreeDepth (T)
初始条件:二叉树T存在。
操作结果:返回T的深度。
Root (T)
初始条件:二叉树T存在。
操作结果:返回T的根。
Value (T,e)
初始条件:二叉树存在,e是中某个结点。
操作结果:返回e的值。
Assign (T, &e, value)
初始条件:二叉树T存在,是T中某个结点。
操作结果:结点e赋值为value。
Parent (T, e)
初始条件:二叉树T存在,e是中某个结点。
审判商树义
操作结果:若e是T的非根结点,则返回它的双亲,否则返回“空”。
LeftChild(T,e)
初始条件:二叉树T存在,是中某个结点。
操作结果:返回e的左孩子。若无左孩子,则返回“空”。
RightChild(T,e)
初始条件:二叉树T存在,e是T中某个结点。1914
操作结果:返回e的右孩子。若无右孩子,则返回“空”。
LeftSibling (T, e)
初始条件:二叉树T存在,e是T中某个结点。
操作结果:返回e的左兄弟。若是T的左孩子或无左兄弟,则返回“空”。
RightSibling (T,e)
初始条件:二叉树T存在,e e是T中某个结点。
操作结果:返回e的右兄弟。若是T的右孩子或无右兄弟,则返回“空”。
InsertChild(&T,P,LR,C) 即行,曾出譲点杂,如可或資社
TOA
即
一同出E抒
初始条件:二叉树T存在,p指向T中某个结点,LR为0或1,非空二叉树与不相交且右子树为空。
操作结果:根据LR为0或1,插入C为T中p所指结点的左或右子树。p所指结点的原有左或右子树则成
为c的右子树。
117

Page 126
118
数据结构(C语言版)(第2版)
MX DeleteChild (&T, p, LR)
初始条件:二叉树存在,p指向T中某个结点,LR为0或1。
操作结果:根据LR为0或1,删除T中所指结点的左或右子树。
PreOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:先序遍历,对每个结点访问一次。
InOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:中序遍历,对每个结点访问一次。
PostOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:后序遍历,对每个结点访问一次。
LevelOrderTraverse (T)
初始条件:二叉树T存在。
操作结果:层序遍历,对每个结点访问一次。
} ADT BinaryTree
5.4 二叉树的性质和存储结构
5.4.1 二叉树的性质
二叉树具有下列重要特性:
性质1 在二叉树的第层上至多有21个结点(≥1)。
证明:利用归纳法容易证得此性质。
i=1时,只有一个根结点。显然,21=2=1是对的。
现在假定对所有的j(1≤j<i),命题成立,即第j层上至多有21个结点。那么,可以证明j=i
时命题也成立。
由归纳假设:第-1层上至多有22个结点。由于二叉树每个结点的度至多为2,故在第î层
上的最大结点数为第-1层上的最大结点数的2倍,即2×2+2=21。
性质2 深度为k的二叉树至多有2-1个结点(k≥1)。
证明:由性质1可见,深度为k的二叉树的最大结点数为
k
(第i层上的最大结点数) = 21 = 2* -1
i=1
i=1
性质3 对任何一棵二叉树T,如果其终端结点数为no,度为2的结点数为2,则no = z2 + 1。
证明:设 nm为二叉树T中度为1的结点数。因为二叉树中所有结点的度均小于或等于2,所
以其结点总数为
n = no + 2 + 22
(5-1)
再看二叉树中的分支数。除了根结点外,其余结点都有一个分支进入,设为分支总数,则
n=B+1。由于这些分支是由度为1或2的结点射出的,所以又有B=nm+2n20
于是得
n = nm + 2nz + 1
(5-2)

Page 127
第5章树和二叉树
由式(5-1)和式(5-2)得果酸菜球失,縣
20 = 22 + 1
现在介绍两种特殊形态的二叉树,它们是满二叉树和完全二叉树。眼
果味,加大会以
满二叉树:深度为k且含有21个结点的二叉树。图5.6(a)所示是一棵深度为4的满二叉树。
8
11 (12
(a)满二叉树
(b)完全二叉树
①
3
(c)非完全二叉树
(d)非完全二叉树
图5.6 特殊形态的二叉树
满二叉树的特点是:每一层上的结点数都是最大结点数,即每一层i的结点数都具有最大
12-10
可以对满二叉树的结点进行连续编号,约定编号从根结点起,自上而下,自左至右。由此可
引出完全二叉树的定义。
完全二叉树:深度为k的,有n个结点的二叉树,当且仅当其每一个结点都与深度为k的满
二叉树中编号从1至n的结点一一对应时,称之为完全二叉树。图5.6(b)所示为一棵深度为4
的完全二叉树。
完全二叉树的特点是:
(1)叶子结点只可能在层次最大的两层上出现;
(2)对任一结点,若其右分支下的子孙的最大层次为1,则其左分支下的子孙的最大层次必
为/或Z+1。图5.6中(c)和(d)不是完全二叉树。
完全二叉树在很多场合下出现,下面的性质和性质5是完全二叉树的两个重要特性。
性质4 具有n个结点的完全二叉树的深度为logzn」+1。
证明:假设深度为k,则根据性质和完全二叉树的定义有
2-1-1 <n≤2-1 或 201≤n<2*
于是k-1≤logzn <k,因为k是整数,所以k=Llogzn」+1。
性质5 如果对一棵有n个结点的完全二叉树(其深度为log2n+1)的结点按层序编号(从
第1层到第Llogzn」+1层,每层从左到右),则对任一结点i(1≤i≤n),有濺射大
①符号Lx表示不大于x的最大整数,反之,[x]表示不小于x的最小整数。
119

Page 128
数据结构(C语言版)(第2版)
(1)如果i=1,则结点i是二叉树的根,无双亲;如果i>1,则其双亲 PARENT(i)是结
点Li/2」。
(2)如果2i>n,则结点无左孩子(结点为叶子结点);否则其左孩子LCHILD()是结点2i。
(3)如果2i+1>n,则结点i无右孩子;否则其右孩子RCHILD(i)是结点2+1。
在此省略证明过程,读者可由图5.7直观地看出性质5所描述的结点与编号的对应关系。
[i/2]
i+1
2i
2i+1
2i+2
21+3
LCHILD (i)
LCHILD (i+1)
i+1
2i
2i+1
...
21+2
2i+3
RCHILD (i) RCHILD (i+1)
(a)结点和+1在同一层上
(b)结点和+1不在同一层上
图5.7 完全二叉树中结点和+1的左、右孩子
5.4.2 二叉树的存储结构
类似线性表,二叉树的存储结构也可采用顺序存储和链式存储两种方式。
1. 顺序存储结构
//-----二叉树的顺序存储表示--
#define MAXTSIZE 100
typedef TElemType SqBiTree [MAXTSIZE];
SqBiTree bt%3B
//二叉树的最大结点数
110号单元存储根结点
顺序存储结构使用一组地址连续的存储单元来存储数据元素,为了能够在存储结构中反
映出结点之间的逻辑关系,必须将二叉树中的结点依照一定的规律安排在这组单元中。
对于完全二叉树,只要从根起按层序存储即可,依次自上而下、自左至右存储结点元素,即
将完全二叉树上编号为的结点元素存储在如上定义的一维数组中下标为-1的分量中。例如,
图5.8(a)所示为图5.6(b)所示完全二叉树的顺序存储结构。
对于一般二叉树,则应将其每个结点与完全二叉树上的结点相对照,存储在一维数组的相应分量
中,图5.6(c)所示二叉树的顺序存储结构如图5.8(b)所示,图中以“0”表示不存在此结点。
1 2 3 4 5 6 7 8 9 10 11 12
2 3 4 5 0 0 0 0 6 7
(a)完全二叉树
(b)一般二叉树
图5.8 二叉树的顺序存储结构
120
由此可见,这种顺序存储结构仅适用于完全二叉树。因为,在最坏的情况下,一个深度为 k
且只有k个结点的单支树(树中不存在度为2的结点)却需要长度为2-1的一维数组。这造成了
存储空间的极大浪费,所以对于一般二叉树,更适合采取下面的链式存储结构。榮星了年
2. 链式存储结构
设计不同的结点结构可构成不同形式的链式存储结构。由二叉树的定义得知,二叉树的结点

Page 129
第5章树和二叉树
(见图5.9(a))由一个数据元素和分别指向其左、右子树的两个分支构成,则表示二叉树的链表
中的结点至少包含3个域:数据域和左、右指针域,如图5.9(b)所示。有时,为了便于找到结
点的双亲,还可在结点结构中增加一个指向其双亲结点的指针域,如图5.9(c)所示。利用这两
种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表,如图5.10所示。链表的头指
针指向二叉树的根结点。容易证得,在含有n个结点的二叉链表中有n+1个空链域。在5.5节中
将会看到可以利用这些空链域存储其他有用信息,从而得到另一种链式存储结构——线索链表。
parent
data因,即午剧
Ichild rchild
lchild
data rchild
lchild
data
parent rchild
(a)二叉树的结点 (b)含有两个指针域的结点结构 (c)含有三个指针域的结点结构
台图5.9 二叉树的结点及其存储结构
A
VAN
AA
B
B
JB
D
CA
BA
ADA
(a)单支树的二叉链表
(b)二叉链表
AGA
图5.10 链表存储结构
(c)三叉链表
界刷衣(S)
在不同的存储结构中,实现二叉树的操作方法也不同,如找结点x的双亲PARENT(T, e),在
三叉链表中很容易实现,而在二叉链表中则需从根指针出发巡查。由此,在具体应用中采用什么
存储结构,除根据二叉树的形态之外还应考虑需进行何种操作。读者可试以5.4.1 小节中定义的各
种操作对以上定义的各种存储结构进行比较。在下一节的二叉树遍历及其应用的算法均采用以下
定义的二叉链表形式实现。
//- - - - -二叉树的二叉链表存储表示
typedef struct BiTNode{
TElemType data;
struct BiTNode *lchild, *rchild;
//结点数据域
//左右孩子指针
}BiTNode *BiTree;
5.5 遍历二叉树和线索二叉树
在二叉树的一些应用中,常常要求在树中查找具有某种特征的结点,或者是对树中的全部结
点逐一进行处理,这就提出了一个遍历二叉树的问题。线索二叉树是在第一次遍历时将结点的前
121

Page 130
122
数据结构(C语言版)(第2版)
驱、后继信息存储下来,便于再次遍历二叉树。
5.5.1 遍历二叉树
1. 遍历二叉树算法描述
遍历二叉树(traversing binary tree)是指按某条搜索路径巡访树中每个结点,使得每个结点
均被访问一次,而且仅被访问一次。访问的含义很广,可以是对结点做各种处理,包括输出结点
的信息,对结点进行运算和修改等。遍历二叉树是二叉树最基本的操作,也是二叉树其他各种操
作的基础,遍历的实质是对二叉树进行线性化的过程,即遍历的结果是将非线性结构的树中结点
排成一个线性序列。由于二叉树的每个结点都可能有两棵子树,因而需要寻找一种规律,以便使
二叉树上的结点能排列在一个线性队列上,从而便于遍历。
回顾二叉树的递归定义可知,二叉树是由3个基本单元组成:根结点、左子树和右子树。因
此,若能依次遍历这三部分,便是遍历了整个二叉树。假如从L、D、R分别表示遍历左子树、访
问根结点和遍历右子树,则可有DLR、LDR、LRD、DRL、RDL、RLD 这6种遍历二叉树的方案。
若限定先左后右,则只有前3种情况,分别称之为先(根)序遍历、中(根)序遍历和后(根)
序遍历。基于二叉树的递归定义,可得下述遍历二叉树的递归算法定义。
先序遍历二叉树的操作定义如下:
若二叉树为空,则空操作;否则
(1)访问根结点;
(2)先序遍历左子树;
(3)先序遍历右子树。
中序遍历二叉树的操作定义如下:
若二叉树为空,则空操作;否则
(1)中序遍历左子树;
(2)访问根结点;
(3)中序遍历右子树。
后序遍历二叉树的操作定义如下:
若二叉树为空,则空操作;否则
(1)后序遍历左子树;
(2)后序遍历右子树;
(3)访问根结点。
例如,图5.5 所示的二叉树表示下述表达式
a + b *(c-d)- e/f
若先序遍历此二叉树,按访问结点的先后次序将结点排列起来,可得到二叉树的先序序列为
-+a*b-cd/ef
(5-3)
类似地,中序遍历此二叉树,可得此二叉树的中序序列为
a+b*c-d-e/f
(5-4)
后序遍历此二叉树,可得此二叉树的后序序列为
abcd− * + ef/ -
(5-5)
从表达式来看,以上3个序列(5-3)(5-4)和(5-5)恰好为表达式的前缀表示(波兰式)、
中缀表示和后缀表示(逆波兰式)。

Page 131
第5章 树和二叉树
算法 5.1 给出了中序遍历二叉树基本操作的递归算法在二叉链表上的实现,算法将结点的访
澣料的
问简化成数据的输出。
算法 5.1 中序遍历的递归算法怪理员
【算法描述】
void InOrderTraverse (BiTree T)
{ //中序遍历二叉树的递归算法
【新西詳】
if(T)
//若二叉树非空
{
InOrderTraverse (T->1child);
//中序遍历左子树
cout<<T->data;
//访问根结点
柳證非g果地上
InOrderTraverse (T->rchild);
//中序遍历右子树
}
【】
}
只要改变输出语句的顺序,读者便可类似地实现先序遍历和后序遍历的递归算法,此处不再
一一列举。
从上述二叉树遍历的定义可知,3种遍历算法不同处仅在于访问根结点和遍历左、右子树的先
后关系。如果在算法中暂且抹去和递归无关的cout语句,则3个遍历算法完全相同。由此,从递归
执行过程的角度来看先序、中序和后序遍历也是完全相同的。图 5.11(b)中用带箭头的虚线表示
了这3种遍历算法的递归执行过程。其中,向下的箭头表示更深一层的递归调用,向上的箭头表示
从递归调用退出返回;虚线旁三角形、圆形和方形内的字符分别表示在先序、中序和后序遍历二叉
树过程中访问结点时输出的信息。例如,由于中序遍历中访问结点是在遍历左子树之后、遍历右子
树之前进行,则带圆形的字符标在向左递归返回和向右递归调用之间。由此,只要沿虚线从1出发
到2结束,将沿途所见的三角形(或圆形、或方形)内的字符记下,便得到遍历二叉树的先序(或
中序、或后序)序列。例如,从图5.11(b)分别可得图5.11(a)所示表达式的前缀表示(-*abc)、
中缀表示(a*b-c)和后缀表示(ab*c-)。
2
ATT
C
A
a
/b\
回回
外出
a
b
a
(a)表达式(a*b-c)的二叉树
(b)遍历的递归执行过程
图5.113种遍历过程示意图
根据前面 3.4.4 小节的内容,可利用栈将递归算法改写成非递归算法,如算法5.2所示。例如,
从中序遍历递归算法执行过程中递归工作栈的状态可见:
(1)工作记录中包含两项,其一是递归调用的语句编号,其二是指向根结点的指针,则当栈
顶记录中的指针非空时,应遍历左子树,即指向左子树根的指针进栈;
(2)若栈顶记录中的指针值为空,则应退至上一层,若是从左子树返回,则应访问当前层(即
123

Page 132
124
数据结构(C语言版)(第2版)
栈顶记录)中指针所指的根结点;
(3)若是从右子树返回,则表明当前层的遍历结束,应继续退栈。从另一个角度看,这意味
着遍历右子树时不再需要保存当前层的根指针,直接修改栈顶记录中的指针即可。
起
示
算法5.2 中序遍历的非递归算法
【算法步骤】
① 初始化一个空栈S,指针指向根结点。
② 申请一个结点空间q,用来存放栈顶弹出的元素。
③当p非空或者找S非空时,循环执行以下操作:
如果p非空,则将p进栈,p指向该结点的左孩子;
如果p为空,则弹出栈顶元素并访问,将p指向该结点的右孩子。
【算法描述】
void InOrderTraverse (BiTree T)
{ //中序遍历二叉树的非递归算法
InitStack (S);p=T;
q=new BiTNode;
while(p||! StackEmpty(S))
if(p)
//p非空
Push (S,p);
//根指针进栈
p=p->lchild;
//根指针进栈,遍历左子树
}
else
/p 为空
{
Pop (S, q);
//退栈
d*) cout<<q-> data;
//访问根结点
p=q->rchild;
//遍历右子树
}
// while
}
按上述算法,图5.11(a)所示的二叉树的中序非递归遍历的栈S的变化过程如图5.12 所示。
P→"b"
b
"
P→“NULL”
P→“NULL”
a
*
*
*
@出栈
*出栈
P→“NULL”
P→“NULL”
P→“NULL”
P→“NULL”
-出栈
C c出栈 栈空
(明)累备回 图5.12 非递归中序遍历时栈的变化情况

Page 133
【算法分析】
第5章树和二叉树
无论是递归还是非递归遍历二叉树,因为每个结点被访问一次,则不论按哪一种次序进行遍
历,对含n个结点的二叉树,其时间复杂度均为O(n)。所需辅助空间为遍历过程中栈的最大容量,
即树的深度,最坏情况下为n,则空间复杂度也为O(n)。
二叉树的先序、中序和后序遍历是最常用的三种遍历方式。此外,还有一种按层次遍历
二叉树的方式,这种方式按照“从上到下,从左到右”的顺序遍历二叉树,即先遍历二叉树
第一层的结点,然后是第二层的结点,直到最底层的结点,对每一层的遍历按照从左到右的
次序进行。例如,图5.11(a)所示的二叉树的层次遍历序列是-*cab。层次遍历不是一个递归
过程,层次遍历算法的实现可以借助队列这种数据结构,这里不做详细讨论,算法留给读者
自行完成。
2. 根据遍历序列确定二叉树
从前面讨论的二叉树的遍历知道,若二叉树中各结点的值均不相同,任意一棵二叉树结点的
先序序列、中序序列和后序序列都是唯一的。反过来,若已知二叉树遍历的任意两种序列,能否
确定这棵二叉树呢?这样确定的二叉树是否是唯一的呢?
由二叉树的先序序列和中序序列,或由其后序序列和中序序列均能唯一地确定一棵二叉树。
根据定义,二叉树的先序遍历是先访问根结点,其次再按先序遍历方式遍历根结点的左子树,
最后按先序遍历方式遍历根结点的右子树。这就是说,在先序序列中,第一个结点一定是二叉树
的根结点。另一方面,中序遍历是先遍历左子树,然后访问根结点,最后再遍历右子树。这样,
根结点在中序序列中必然将中序序列分割成两个子序列,前一个子序列是根结点的左子树的中序
序列,而后一个子序列是根结点的右子树的中序序列。根据这两个子序列,在先序序列中找到对
应的左子序列和右子序列。在先序序列中,左子序列的第一个结点是左子树的根结点,右子序列
的第一个结点是右子树的根结点。这样,就确定了二叉树的三个结点。同时,左子树和右子树的
根结点又可以分别把左子序列和右子序列划分成两个子序列,如此递归下去,当取尽先序序列中
的结点时,便可以得到一棵二叉树。
同理,由二叉树的后序序列和中序序列也可唯一地确定一棵二叉树。因为,依据后序遍历和
中序遍历的定义,后序序列的最后一个结点,就如同先序序列的第一个结点一样,可将中序序列
分成两个子序列,分别为这个结点左子树的中序序列和右子树的中序序列,再拿出后序序列的倒
数第二个结点,并继续分割中序序列,如此递归下去,当倒着取尽后序序列中的结点时,便可以
得到一棵二叉树。
【例 5.1】 已知一棵二叉树的中序序列和后序序列分别是 BDCEAFHG 和 DECBHGFA,请
画出这棵二叉树。
(1)由后序遍历特征,根结点必在后序序列尾部,即根结点是A;
(2)由中序遍历特征,根结点必在其中间,而且其左部必全部是左子树子孙(BDCE),其右
部必全部是右子树子孙(FHG);
(3)继而,根据后序中的DECB子树可确定为A的左孩子,根据HGF子串可确定F为A
的右孩子;依此类推,可以唯一地确定一棵二叉树,如图5.13所示。
但是,由一棵二叉树的先序序列和后序序列不能唯一确定一棵二叉树,因为无法确定左右子
树两部分。例如,如果有先序序列AB,后序序列BA,因为无法确定B为左子树还是右子树,所
以可得到如图5.14所示的两棵不同的二叉树。 斯·江西
125

Page 134
数据结构(C语言版)(第2版)
正
A
G
A
A
D
E
H
B
B
新图5.13 由中序序列和后序序列确定的二叉树
图5.14两棵不同的二叉树
3. 二叉树遍历算法的应用
“遍历”是二叉树各种操作的基础,假设访问结点的具体操作不仅仅局限于输出结点数
据域的值,而把“访问”延伸到对结点的判别、计数等其他操作,可以解决一些关于二叉树
的其他实际问题。如果在遍历过程中生成结点,这样便可建立二叉树的存储结构。
(1)创建二叉树的存储结构——二叉链表
为简化问题,设二叉树中结点的元素均为一个单字符。假设按先序遍历的顺序建立二叉链表,
T 为指向根结点的指针,对于给定的一个字符序列,依次读入字符,从根结点开始,递归创建二
叉树。
算法 5.3 先序遍历的顺序建立二叉链表
【算法步骤】
① 扫描字符序列,读入字符 ch。
② 如果 ch 是一个“#”字符,则表明该二叉树为空树,即T为NULL;否则执行以下操作:
●申请一个结点空间 T;
将ch 赋给T->data;
● 递归创建T的左子树;
递归创建T的右子树;
【算法描述】
void CreateBiTree (BiTree &T)
{ //按先序次序输入二叉树中结点的值(一个字符),创建二叉链表表示的二叉树 T
cin>>ch;
if(ch=='#') T=NULL;
else
{
( T=new BiTNode;
//递归结束,建空树
//递归创建二叉树
//生成根结点
//根结点数据域置为 ch
T->data=ch;
AT CreateBiTree(T->lchild);
//递归创建左子树
CreateBiTree (T->rchild);
//递归创建右子树
//else
类
126
例如,对图 5.10(b)所示的二叉树,读入字符的顺序为:ABC##DE#G##F### (其中#表示
空树),可建立相应的二叉链表。

Page 135
(2)复制二叉树
第5章树和二叉树
复制二叉树就是利用已有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉
树的特点,复制步骤如下:若二叉树不空,则首先复制根结点,这相当于二叉树先序遍历算法中
访问根结点的语句;然后分别复制二叉树根结点的左子树和右子树,这相当于先序遍历中递归遍
历左子树和右子树的语句。因此,复制函数的实现与二叉树先序遍历的实现非常类似。
算法5.4 复制二叉树
【算法步骤】
我不限素菜中叉二卡 6.
如果是空树,递归结束,否则执行以下操作:
【名】
申请一个新结点空间,复制根结点;
递归复制左子树;
● 递归复制右子树。
【算法描述】
void Copy(BiTree T,BiTree &NewT)
{//复制一棵和T完全相同的二叉树
if(T==NULL)
{
NewT=NULL;
return;
}
else
{
//如果是空树,递归结束
NewT=new BiTNode:一个一冊点器随中文
NewT->data=T->data;
Copy(T->lchild,NewT->lchild);
Copy (T->rchild,NewT->rchild);
//复制根结点
//递归复制左子树
//递归复制右子树
//else
(3)计算二叉树的深度
匠
二叉树的深度为树中结点的最大层次,二叉树的深度为左右子树深度的较大者加1。
算法 5.5 计算二叉树的深度
【算法步骤】
如果是空树,递归结束,深度为0,否则执行以下操作:
● 递归计算左子树的深度记为m;
递归计算右子树的深度记为n;
如果 m 大于n,二叉树的深度为m+1,否则为n+1。
【算法描述】
int Depth(BiTree T)
{ //计算二叉树T 的深度
if(T==NULL) return 0;
else
{
Mid
//如果是空树,深度为0,递归结束
_m=Depth (T->lchild);
//递归计算左子树的深度记为mbidof
n=Depth (T->rchild);
//递归计算右子树的深度记为nlingl
if(m>n) return (m+1);
//二叉树的深度为man的较大者加1
127

Page 136
128
数据结构(C语言版)(第2版)
else return(n+1);
}
显然,计算二叉树的深度是在后序遍历二叉树的基础上进行的运算。
(4)统计二叉树中结点的个数
如果是空树,则结点个数为0;否则,结点个数为左子树的结点个数加上右子树的结点个数
再加上1。
算法 5.6 统计二叉树中结点的个数
【算法描述】
int NodeCount (BiTree T)
{ //统计二叉树T中结点的个数
}
if(T==NULL) return 0;
//如果是空树,则结点个数为0,递归结束
else return NodeCount (T->lchild)+NodeCount(T->rchild)+1;
//否则结点个数为左子树的结点个数+右子树的结点个数+1
读者可以模仿此算法,写出以下算法:统计二叉树中叶结点(度为0)的个数,为 1 的
结点个数和度为2的结点个数。算法实现的关键是如何表示度为0、度为1或度为2的结点。
5.5.2 线索二叉树
1. 线索二叉树的基本概念
遍历二叉树是以一定规则将二叉树中的结点排列成一个线性序列,得到二叉树中结点的先序
序列、中序序列或后序序列。这实质上是对一个非线性结构进行线性化操作,使每个结点(除第
一个和最后一个外)在这些线性序列中有且仅有一个直接前驱和直接后继(在不至于混淆的情况,
后续描述中省去“直接”二字。例如在图5.5所示的二叉树结点的中序序列a+b*c-d-e/f中,“c”
的前驱是“*”,后继是“-”。
但是,当以二叉链表作为存储结构时,只能找到结点的左、右孩子信息,而不能直接得
到结点在任一序列中的前驱和后继信息,这种信息只有在遍历的动态过程中才能得到,为此
引入线索二叉树来保存这些在动态过程中得到的有关前驱和后继的信息。
虽然可以在每个结点中增加两个指针域来存放在遍历时得到的有关前驱和后继信息,但这样
做使得结构的存储密度大大降低。由于有n个结点的二叉链表中必定存在n+1个空链域,因此
可以充分利用这些空链域来存放结点的前驱和后继信息。
试做如下规定:若结点有左子树,则其Ichild 域指示其左孩子,否则令 lchild 域指示其前驱;
若结点有右子树,则其rchild 域指示其右孩子,否则令rchild 域指示其后继。为了避免混淆,尚
需改变结点结构,增加两个标志域,其结点形式如图 5.15 所示。
lchild
LTag
data
RTag
rchild)
图5.15线索二叉树的结点形式
(LIU
其中:
[0 lchild域指示结点的左孩子
LTag:
=
1 lchild域指示结点的前驱
cuter (n<m) 11

Page 137
970
RTag =
第5章树和二叉树
lchild域指示结点的左孩子
索中树干g
1 lchild域指示结点的后继
二叉树的二叉线索类型定义如下:
1-----二叉树的二叉线索存储表示--___王叫。詳興
typedef struct BiThrNode
TElemType data;
struct BiThrNode *lchild, *rchild;
//左右孩子指针
int LTag,RTag;
}BiThrNode *BiThrTree;
//左右标志
果戚
以这种结点结构构成的二叉链表作为二叉树的存储结构,叫做线索链表,其中指向结点前驱
和后继的指针,叫做线索。加上线索的二叉树称之为线索二叉树(Threaded Binary Tree)。对二叉
树以某种次序遍历使其变为线索二叉树的过程叫做线索化。
例如图 5.16(a)所示为中序线索二叉树,与其对应的中序线索链表如图5.16(b)所示。其
中实线为指针(指向左、右子树),虚线为线索(指向前驱和后继)。为了方便起见,仿照线性表
的存储结构,在二叉树的线索链表上也添加一个头结点,并令其 Ichild 域的指针指向二叉树的根
结点,其 rchild 域的指针指向中序遍历时访问的最后一个结点;同时,令二叉树中序序列中第一
个结点的 lchild 域指针和最后一个结点rchild 域的指针均指向头结点。这好比为二叉树建立了一
个双向线索链表,既可从第一个结点起顺后继进行遍历,也可从最后一个结点起顺前驱进行遍历。
2.构造线索二叉树
由于线索二叉树构造的实质是将二叉链表中的空指针改为指向前驱或后继的线索,而前驱或
后继的信息只有在遍历时才能得到,因此线索化的过程即为在遍历的过程中修改空指针的过程,
可用递归算法。对二叉树按照不同的遍历次序进行线索化,可以得到不同的线索二叉树,包括先
序线索二叉树、中序线索二叉树和后序线索二叉树。下面重点介绍中序线索化的算法。
为了记下遍历过程中访问结点的先后关系,附设一个指针 pre 始终指向刚刚访问过的结点,而指针
p指向当前访问的结点,由此记录下遍历过程中访问结点的先后关系。算法5.7 是对树中任意一个结点
p为根的子树中序线索化的过程,算法5.8通过调用算法5.7来完成整个二叉树的中序线索化。
thrt
NULL
NULL
+0
bt
8.
【食】
*
e
f
10-01911
C
d 1
(a)中序线索二叉树
(b)中序线索链表
图5.16线索二叉树及其存储结构
129

Page 138
130
数据结构(C语言版)(第2版)
算法 5.7 以结点p为根的子树中序线索化
【算法步骤】
①如果p非空,左子树递归线索化。
② 如果p的左孩子为空,则给p加上左线索,将其LTag置为1,让p的左孩子指针指向 pre
(前驱);否则将p的LTag置为0。
如果 pre 的右孩子为空,则给pre加上右线索,将其RTag置为1,让pre的右孩子指针指
向p(后继);否则将 pre 的RTag 置为0。
④将 pre 指向刚访问过的结点p,即 pre = po
⑤ 右子树递归线索化。
【算法描述】
void InThreading (BiThrTree p)
{//pre 是全局变量,初始化时其右孩子指针为空,便于在树的最左点开始建线索
if (p)
{
{
TV
InThreading (p->lchild);
if(!p->lchild)
p->LTag=1;
p->lchild=pre;
else p->LTag=0;
if(!pre->rchild)
//左子树递归线索化
//p的左孩子为空
//给p加上左线索
//p的左孩子指针指向
pre(前驱)
//if
//pre的右孩子为空
}
}
}
pre->RTag=1;
pre->rchld=p;
else p->RTag=0;
pre=p:
InThrending(p->rchild);
//给pre加上右线索
//pre的右孩子指针指向p(后继)
//if
//保持pre 指向p的前驱
//右子树递归线索化
算法5.8 带头结点的二叉树中序线索化
【算法描述】
void InOrderThreading(BiThrTree &Thrt, BiThrTree T)
{ //中序遍历二叉树,并将其中序线索化,Thrt 指向头结点
Thrt=new BiThrNode;
Thrt->LTag=0;
//建头结点
Thrt->RTag=1;
Thrt->rchild=Thrt;
Thrt->lchild=Thrt;
if(!T)
else
{
Thrt->lchild=T; pre=Thrt;
InThreading (T);
pre->rchild=Thrt;
pre->RTag=1;
//头结点有左孩子,若树非空,则其左孩子为树根
//头结点的右孩子指针为右线索
//初始化时右指针指向自己
//若树为空,则左指针也指向自己
//头结点的左孩子指向根,pre初值指向头结点
//调用算法5.7,对以为根的二叉树进行中序线索化
//算法5.7 结束后,pre为最右结点,pre的线索指向头结点

Page 139
第5章树和二叉树
Thrt->rchild=pre;
//头结点的右线索指向pre
}
3. 遍历线索二叉树
由于有了结点的前驱和后继信息,线索二叉树的遍历和在指定次序下查找结点的前驱和后继
算法都变得简单。因此,若需经常查找结点在所遍历线性序列中的前驱和后继,则采用线索链表
作为存储结构。
下面分3种情况讨论在线索二叉树中如何查找结点的前驱和后继。
(1)在中序线索二叉树中查找
① 查找指针所指结点的前驱:
面
綜叉二
田
其
2.職
若 p-> LTag为1,则p的左链指示其前驱;
若 p- > LTag 为0,则说明p有左子树,结点的前驱是遍历左子树时最后访问的一个结
点(左子树中最右下的结点)。
②查找指针所指结点的后继:
若 p- > RTag 为1,则p的右链指示其后继,以图5.16所示的中序线索树为例来看,结
点b的后继为结点*;
若 p-> RTag为0,则说明p有右子树。根据中序遍历的规律可知,结点的后继应是遍
历其右子树时访问的第一个结点,即右子树中最左下的结点。例如在找结点*的后继时,
首先沿右指针找到其右子树的根结点-,然后顺其左指针往下直至其左标志为1的结
点,即为结点*的后继,在图中是结点 c。
(2)在先序线索二叉树中查找
① 查找p指针所指结点的前驱:
若p->LTag为1,则p的左链指示其前驱;
若 p- > LTag 为0,则说明p有左子树。此时p的前驱有两种情况:若*p是其双亲的左
孩子,则其前驱为其双亲结点;否则应是其双亲的左子树上先序遍历最后访问到的结点。
查找p指针所指结点的后继:
若p->RTag为1,则p的右指示其后继;
● 若p->RTag为0,则说明有右子树。按先序遍历的规则可知,*p的后继必为其左子
树根(若存在)或右子树根。
(3)在后序线索二叉树中查找
① 查找p指针所指结点的前驱:
● 若p->LTag为1,则p的左链指示其前驱;
若 p- > LTag 为0,当p->RTag也为0时,则p的右指示其前驱;若p-> LTag 为 0,
而p->RTag为1时,则p的左链指示其前驱。
②查找p指针所指结点的后继情况比较复杂,分以下情况讨论:
● 若*p 是二叉树的根,则其后继为空;
● 若*p 是其双亲的右孩子,则其后继为双亲结点;
● 若*p 是其双亲的左孩子,且*p没有右兄弟,则其后继为双亲结点;
若*p是其双亲的左孩子,且*p有右兄弟,则其后继为双亲的右子树上按后序遍历列出
的第一个结点(即右子树中“最左下”的叶结点)。
131

Page 140
数据结构(C语言版)(第2版)
例如,图5.17 所示为后序线索二叉树,结点B的后继为结点
C,结点 C 的后继为结点D,结点F的后继为结点G,而结点D
的后继为结点E。
可见,在先序线索化树上找前驱或在后序线索化树上找后继
时都比较复杂,此时若需要,可直接建立含4个指针的线索链表。
出
图5.17 后序后继线索二叉树
由于有了结点的前驱和后继的信息,线索二叉树的遍历操作
无需设栈,避免了频繁的进栈、出栈,因此在时间和空间上都较
遍历二叉树节省。如果遍历某种次序的线索二叉树,则只要从该次序下的根结点出发,反复查找
其在该次序下的后继,直到叶子结点。下面以遍历中序线索二叉树为例介绍该算法。
算法5.9 遍历中序线索二叉树
【算法步骤】
① 指针p指向根结点。
②p为非空树或遍历未结束时,循环执行以下操作:
沿左孩子向下,到达最左下结点*p,它是中序的第一个结点;
访问*p;
● 沿右线索反复查找当前结点*p的后继结点并访问后继结点,直至右线索为0或者遍
历结束;
转向p的右子树。
【算法描述】
void InOrderTraverse_Thr (BiThrTree T)
中文
{//T 指向头结点,头结点的左child 指向根结点,可参见线索化算法5.8。
//中序遍历二叉线索树的非递归算法,对每个数据元素直接输出
p=T->lchild;
while (p!=T)
//p指向根结点
//空树或遍历结束时,p==T
while(p->LTag==0) p=p->lchild;
cout<<p->data;
Tan while(p->RTag==1&&p->rchild!=T)
//沿左孩子向下
//访问其左子树为空的结点
乐视
p=p->rchild; cout<<p->data;
//沿右线索访问后继结点
}
p=p->rchild;
//转向p的右子树
}
【算法分析】
遍历线索二叉树的时间复杂度为O(n),空间复杂度为O(1),这是因为线索二叉树的遍历不需
要使用栈来实现递归操作。
5.6 树和森林
132
本节将讨论树的表示及其遍历操作,并建立森林与二叉树的对应关系。

Page 141
5.6.1 树的存储结构
第5章树和二叉树
在大量的应用中,人们曾使用多种形式的存储结构来表示树。这里介绍3种常用的表示
方法。
1. 双亲表示法
这种表示方法中,以一组连续的存储单元存储树的结点,每个结点除了数据域data外,还附
设一个 parent 域用以指示其双亲结点的位置,其结点形式如图5.18所示。
例如,图5.19 所示为一棵树及其双亲表示的存储结构。
数组下标
0 R
-1
1
A
0 兄于
2
B
0
(G) (HK
34
567 .
3
C
D
1
E
1
F
3.
G
6
8
H
6
data parent
9 K 6
aldialxon
图5.18 双亲表示法的结点形式
图5.19 树的双亲表示法示例
这种存储结构利用了每个结点(除根以外)只有唯一的双亲的性质。在这种存储结构下,求
结点的双亲十分方便,也很容易求树的根,但求结点的孩子时需要遍历整个结构。
2.孩子表示法
由于树中每个结点可能有多棵子树,则可用多重链表,即每个结点有多个指针域,其中每个
指针指向一棵子树的根结点,此时链表中的结点可以有如图5.20所示的两种结点格式。
data
child1 child2
childd
data
degree child1
child2
...
childd blirfotard A
图5.20 孩子表示法的两种结点
gnildierxan
若采用第一种结点格式,则多重链表中的结点是同构的,其中d为树的度。由于树中很多结
点的度小于d,所以链表中有很多空链域,空间较浪费,不难推出,在一棵有n个结点度为k的
树中必有n(k-1)+1个空链域。
若采用第二种结点格式,则多重链表中的结点是不同构的,其中d为结点的度,degree 域的
值同d。此时,虽能节约存储空间,但操作不方便。
另一种办法是,把每个结点的孩子结点排列起来,看成是一个线性表,且以单链表做存储结
构,则n个结点有n个孩子链表(叶子的孩子链表为空表)。而n个头指针又组成一个线性表,为
了便于查找,可采用顺序存储结构。
图 5.21(a)所示为图5.19中的树的孩子表示法。与双亲表示法相反,孩子表示法便于
那些涉及孩子的操作的实现。可以把双亲表示法和孩子表示法结合起来,即将双亲表示和孩
子链表合在一起。图5.21(b)所示的就是这种存储结构的一例,它和图5.21(a)表示的是
同一棵树。
133

Page 142
134
数据结构(C语言版)(第2版)
0A
+ 3 5A
1 B Λ
2 C
6 A
米米3D
Λ
4
R
7 01 11 2^
56789
E
Λ
F
☐ 7 8 9A
4440702
0123
30
4-1
67
R
5 0
E
F
A
B
Λ
C
D ^
35A
6 A
☐ 01 11 2^
Λ
☐ 71 87 9A
7
G
Λ
7
6
G ^
8
H
Λ
8
6
H Λ
K
Λ
9
6 K
(a)孩子链表
(b)带双亲的孩子链表
图5.21 图5.19的树的另外两种表示法
3.孩子兄弟法
又称二叉树表示法,或二叉链表表示法,即以二叉链表做树的存储结构。链表中结点的两个
链域分别指向该结点的第一个孩子结点和下一个兄弟结点,分别命名为firstchild 域和 nextsibling
域,其结点形式如图 5.22 所示。
firstchild
data
nextsibling
图5.22 孩子兄弟表示法的结点
steb
//---- -树的二叉链表(孩子-兄弟)存储表示-
typedef struct CSNode{
ElemType data;
struct CSNode *firstchild, *nextsibling;
}CSNode, *CSTree;
图5.23 所示为图5.19中的树的孩子兄弟链表。利用这种
存储结构便于实现各种树的操作。首先易于实现找结点孩子
等的操作。例如,若要访问结点x的第i个孩子,则只要先
从 firstchild 域找到第1个孩子结点,然后沿着孩子结点的
nextsibling 域连续走-1步,便可找到x的第i个孩子。当然,
如果为每个结点增设一个 parent 域,则同样能方便地实现查
找双亲的操作。
这种存储结构的优点是它和二叉树的二叉链表表示完
全一样,便于将一般的树结构转换为二叉树进行处理,利
用二叉树的算法来实现对树的操作。因此孩子兄弟表示法
是应用较为普遍的一种树的存储表示方法。
5.6.2 森林与二叉树的转换水
RA
AD
AB
MEN
F
AG
图5.23 图5.19中树的二叉链表表示法
平和)赤益干期:
从树的二叉链表表示的定义可知,任何一棵树对应的二叉树,其根结点的右子树必空。若
把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟,则同样可导出森林和二叉树的对应
关系。
例如,图5.24 所示为森林与二叉树之间的对应关系。

Page 143
G 森林与二叉树对应A
第5章树和二叉树
(B
B
E
树与二叉树对应
E
树根相连
①
①
图5.24 森林与二叉树的对应关系示例
这个一一对应的关系说明森林或树与二叉树可以相互转换。
1. 森林转换成二叉树
如果F = {Ti, T2,…,Tm}是森林,则可按如下规则转换成一棵二叉树B=(root, LB, RB)。
(1)若F为空,即m=0,则B为空树;
(2)若F非空,即m≠0,则B的根 root即为森林中第一棵树的根ROOT(Ti);B的左子树
LB 是从中根结点的子树森林F={T1,Ti2,...,Tim}转换而成的二叉树;其右子树RB是从森林
F' = {T2, T3,…,T}转换而成的二叉树。
2. 二叉树转换成森林
如果B = (root, LB,RB)是一棵二叉树,则可按如下规则转换成森林F= {T\, Tz, ..., Tm}:
(1)若B为空,则F为空;
(2)若B非空,则F中第一棵树的根ROOT(T)即为二叉树B的根 root;T中根结点的子
树森林F是由B的左子树LB转换而成的森林;F中除之外其余树组成的森林F={T2,T3,..., Tm}
是由B的右子树RB转换而成的森林。
从上述递归定义容易写出相互转换的递归算法。同时,森林和树的操作亦可转换成二叉树的
操作来实现。
5.6.3 树和森林的遍历
1. 树的遍历
由树结构的定义可引出两种次序遍历树的方法:一种是先根(次序)遍历树,即:先访问树
的根结点,然后依次先根遍历根的每棵子树;另一种是后根(次序)遍历,即先依次后根遍历每
棵子树,然后访问根结点。
例如,对图 5.19 所示的树进行先根遍历,可得树的先根序列为:
RADEBCF GHK
若对此树进行后根遍历,则得树的后根序列为:
扫
DEABGHKFCR
按照森林和树相互递归的定义,可以推出森林的两种遍历方法:先序遍历和中序遍历。
2. 森林的遍历
(1)先序遍历森林
若森林非空,则可按下述规则遍历:
① 访问森林中第一棵树的根结点;
135

Page 144
数据结构(C语言版)(第2版)
② 先序遍历第一棵树的根结点的子树森林;
③ 先序遍历除去第一棵树之后剩余的树构成的森林。
(2)中序遍历森林
若森林非空,则可按下述规则遍历:
中序遍历森林中第一棵树的根结点的子树森林;
② 访问第一棵树的根结点;
③ 中序遍历除去第一棵树之后剩余的树构成的森林。
若对图 5.24 中所示的森林进行先序遍历和中序遍历,则分别得到森林的先序序列为:
中序序列为:
ABCDEFGHIJ
BCDAFEHJIG
136
由5.6.2小节森林与二叉树之间转换的规则可知,当森林转换成二叉树时,其第一棵树的子树
森林转换成左子树,剩余树的森林转换成右子树,则上述森林的先序和中序遍历即为其对应的二
叉树的先序和中序遍历。若对图5.24中所示的和森林对应的二叉树分别进行先序和中序遍历,可
得和上述相同的序列。
由此可见,当以二叉链表做树的存储结构时,树的先根遍历和后根遍历可借用二叉树的先序
遍历和中序遍历的算法实现。
5.7 哈夫曼树及其应用
树结构是一种应用非常广泛的结构,在一些特定的应用中,树具有一些特殊特点,利用这些
特点可以解决很多工程问题。在5.2节提出的应用案例5.1可以借助一种应用很广的树——哈夫曼
树来解决,本节便以哈夫曼树为例,说明二叉树的一个具体应用。
5.7.1 哈夫曼树的基本概念
哈夫曼(Huffman)树又称最优树,是一类带权路径长度最短的树,在实际中有广泛的用途。
哈夫曼树的定义,涉及路径、路径长度、权等概念,下面先给出这些概念的定义,然后再介绍哈
夫曼树。
(1)路径:从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。
(2)路径长度:路径上的分支数目称作路径长度。
(3)树的路径长度:从树根到每一结点的路径长度之和。
(4)权:赋予某个实体的一个量,是对实体的某个或某些属性的数值化描述。在数据结构中,
实体有结点(元素)和边(关系)两大类,所以对应有结点权和边权。结点权或边权具体代表什
么意义,由具体情况决定。如果在一棵树中的结点上带有权值,则对应的就有带权树等概念。
(5)结点的带权路径长度:从该结点到树根之间的路径长度与结点上权的乘积。
歐
(6)树的带权路径长度:树中所有叶子结点的带权路径长度之和,通常记作WPL = Z walk o
k=1
(7)哈夫曼树:假设有m个权值{W1,W2,..., Wm},可以构造一棵含n个叶子结点的二叉树,
每个叶子结点的权为w;,则其中带权路径长度 WPL 最小的二叉树称做最优二叉树或哈夫曼树。

Page 145
第5章树和二叉树
例如,图 5.25 中所示的3棵二叉树,都含4个叶子结点a、b、c、d,分别带权7、5、2、4,
它们的带权路径长度分别为
7
4
(a)WPL=7×2+5×2+2×2+4×2=36
5
(b)WPL=7×3+5×3+2×1+4×2= 46
(c)WPL=7×1+5×2+2×3+4×3= 35
图5.25 具有不同带权路径长度的二叉树
其中以(c)树的为最小。可以验证,它恰为哈夫曼树,即其带权路径长度在所有带权为7、5、2、
4的4个叶子结点的二叉树中居最小。
哈夫曼树中具有不同权值的叶子结点的分布有什么特点呢?从上面的例子中,可以直观地发
现,在哈夫曼树中,权值越大的结点离根结点越近。根据这个特点,哈夫曼最早给出了一个构造
哈夫曼树的方法,称哈夫曼算法。
5.7.2 哈夫曼树的构造算法
1.哈夫曼树的构造过程
(1)根据给定的n个权值{W1,W2,…,wn},构造n棵只有根结点的二叉树,这n棵二叉树构成
一个森林F。
(2)在森林 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树,且
置新的二叉树的根结点的权值为其左、右子树上根结点的权
值之和。
7 5
4
7
5 6
a
(3)在森林F中删除这两棵树,同时将新得到的二叉树加
入F中。
(b)
7
11
18
(4)重复(2)和(3),直到F只含一棵树为止。这棵树
便是哈夫曼树。
a
在构造哈夫曼树时,首先选择权小的,这样保证权大的离
根较近,这样一来,在计算树的带权路径长度时,自然会得到
最小带权路径长度,这种生成算法是一种典型的贪心法。
过程。其中,根结点上标注的数字是所赋的权。
例如,图 5.26 所示为图5.25(c)所示的哈夫曼树的构造
(c)
(d)
图5.26 哈夫曼树的构造过程
137

Page 146
数据结构(C语言版)(第2版)
2.哈夫曼算法的实现
哈夫曼树是一种二叉树,当然可以采用前面介绍过的通用存储方法,而由于哈夫曼树中没有
度为1的结点,则一棵有n个叶子结点的哈夫曼树共有2n-1个结点,可以存储在一个大小为2n-1
的一维数组中。树中每个结点还要包含其双亲信息和孩子结点的信息,由此,每个结点的存储结
构设计如图5.27 所示。
weight
parent
lchild
rchild
图5.27 哈夫曼树结点的形式
//-
---
-哈夫曼树的存储表示
typedef struct {
int weight;
int parent,lchild,rchild;
}HTNode *HuffmanTree;
//结点的权值
//结点的双亲、左孩子、右孩子的下标
//动态分配数组存储哈夫曼树
哈夫曼树的各结点存储在由 HuffmanTree 定义的动态分配的数组中,为了实现方便,数组的
0号单元不使用,从1号单元开始使用,所以数组的大小为2n。将叶子结点集中存储在前面部分
1~n 个位置,而后面的n-1 个位置存储其余非叶子结点。
算法 5.10 构造哈夫曼树
【算法步骤】
构造哈夫曼树算法的实现可以分成两大部分。
① 初始化:首先动态申请2n个单元;然后循环2n-1次,从1号单元开始,依次将1至2n-1
所有单元中的双亲、左孩子、右孩子的下标都初始化为0;最后再循环n次,输入前n个单元中
叶子结点的权值。
② 创建树:循环n-1 次,通过n-1次的选择、删除与合并来创建哈夫曼树。选择是从当前
森林中选择双亲为0且权值最小的两个树根结点s1和s2;删除是指将结点s1和2的双亲改为非
0; 合并就是将s1和2的权值和作为一个新结点的权值依次存入到数组的第n+1之后的单元中,
同时记录这个新结点左孩子的下标为s1,右孩子的下标为s2。
【算法描述】
void CreateHuffmanTree (HuffmanTree &HT,int n)
{ //构造哈夫曼树 HT
if(n<=1) return;
m=2*n-1;
HT=new HTNode[m+1];
for(i=1;i<=m;++i)
110号单元未用,所以需要动态分配m+1个单元,HT[m]表示根结点
//将1~m号单元中的双亲、左孩子,右孩子的下标都初始化为0
{HT[i].parent=0;HT[i].lchild=0;HT[i].rchild=0; }
for(i=1;i<=n;++i)
cin>>HT[i].weight;
//输入前n个单元中叶子结点的权值
138
/*-
for(i=n+1;i<=m;++i)
-初始化工作结束,下面开始创建哈夫曼树-
{ //通过n-1 次的选择、删除、合并来创建哈夫曼树
Select (HT, i-1, s1, s2);
//在HT [k] (1≤x≤i-1)中选择两个其双亲域为0且权值最小的结点,并返回它们在HT中的序号 s1 和 s2

Page 147
MG HT[s1].parent=i;HT[s2].parent=i;
//得到新结点,从森林中删除s1,s2,将s1和2的双亲域由0改为i
HT[i].lchild=s1;HT[i].rchild=s2;
HT[i].weight=HT[s1].weight+HT[s2].weight;
}
}
第5章树和二叉树
//s1,s2分别作为的左右孩子
//i的权值为左右孩子权值之和
//for
【例 5.2 】 已知w = (5,29,7,8,14,23,3,11),利用算法 5.10 试构造一棵哈夫曼树,计算树的带
权路径长度,并给出其构造过程中存储结构HT 的初始状态和终结状态。
n = 8,则m = 15,按算法5.10可构造一棵哈夫曼树,如图5.28所示。
23
29
(11
(14)
中擗曼未剑館市
8
拉四曼夫郃(S)
图5.28例5.2的哈夫曼树
树的带权路径长度计算如下:
n
曼大餅
WPL =
= 23 × 2 + 11 × 3+5×4+3×4+29×2+14×3+7×4+8×4= 271
k=1
其存储结构 HT 的初始状态如表5.2(a)所示,其终结状态如表5.2(b)所示。開撕
表5.2
例 5.2 的存储结构
(a)HT 的初态
(b)HT 的终态
结点i weight parent lchild
rchild
结点i
weight parent
lchild rchild
1
5
0
0
0
1
5
9
0
0
2
29
0
0
0
2
29
14
0
0
3
7
0
0
0
3
7
10
4
8
0
0
0
4
8
10
00
0
0
5
14
0
0
0
5
14
12
0
0
宣告
6
23
0
0
0
6
23
13
0
0
7
3
0
0
0
7
3
9
0
0
8
11
0
0
8
11
11
0
9
0
0
0
9
8
11
1
17
10
0
0
(回曼$10
15
12
3
4
.11
0
0
11
19
13
8
9
12
0
0
0
12
29
14
5
10
13
0
0
0
13
42
15
6
11
14
0
0
0
14
58
15
2
12
15
0
0
0
15
100
0
13
14
139

Page 148
140
数据结构(C语言版)(第2版)
哈夫曼树在通信、编码和数据压缩等技术领域有着广泛的应用,下面讨论一个构造通信码的
典型应用——哈夫曼编码。
5.7.3 哈夫曼编码
1. 哈夫曼编码的主要思想
在5.2节提出的案例5.1中已经讨论,在进行数据压缩时,为了使压缩后的数据文件尽可能短,
可采用不定长编码。其基本思想是:为出现次数较多的字符编以较短的编码。为确保对数据文件
进行有效的压缩和对压缩文件进行正确的解码,可以利用哈夫曼树来设计二进制编码。哈夫曼树
的具体构造过程可以根据算法5.10,图5.26所示为图5.4所示的哈夫曼树的构造过程。在图 5.4
所示的哈夫曼树中,约定左分支标记为0,右分支标记为1,则根结点到每个叶子结点路径上的0、
1序列即为相应字符的编码。
下面给出有关编码的两个概念。
(1)前缀编码:如果在一个编码方案中,任一个编码都不是其他任何编码的前缀(最左子串),
则称编码是前缀编码。例如,案例5.1中的第2种编码方案(见表5.1(b))的编码 0,10,110,
111 是前缀编码,而第3种编码方案(见表5.1(c))的编码0,01,010,111 就不是前缀编码。
前缀编码可以保证对压缩文件进行解码时不产生二义性,确保正确解码。
(2)哈夫曼编码:对一棵具有n个叶子的哈夫曼树,若对树中的每个左分支赋予 0,右分支
赋予 1,则从根到每个叶子的路径上,各分支的赋值分别构成一个二进制串,该二进制串就称为
哈夫曼编码。
哈夫曼编码满足下面的两个性质。
性质1 哈夫曼编码是前缀编码。
证明:哈夫曼编码是根到叶子路径上的编码序列,由树的特点知,若路径A是另一条路经 B
的最左部分,则B 经过了A,则A的终点一定不是叶子。而哈夫曼编码对应路径的终点一定为叶
子,因此,任一哈夫曼码都不会与任意其他哈夫曼编码的前缀部分完全重叠,因此哈夫曼编码是
前缀编码。
性质2 哈夫曼编码是最优前缀编码。
对于包括n个字符的数据文件,分别以它们的出现次数为权值构造哈夫曼树,则利用该树对
应的哈夫曼编码对文件进行编码,能使该文件压缩后对应的二进制文件的长度最短。
证明:假设每种字符在数据文件中出现的次数为w,其编码长度为,文件中只有种字符,
则文件总长为 = w 。对应到二叉树上,若置w为叶子结点的权,恰为从根到叶子的路径长度,
i=1
则 w恰为二叉树上带权路径长度。由此可见,设计文件总长最短的二进制前缀编码问题,就
i=1
是以n种字符出现的频率作权设计一棵哈夫曼树的问题。而由哈夫曼树的构造方法可知,出现次
数较多的字符对应的编码较短,这便直观地说明了该定理是成立的。
下面给出根据哈夫曼树构造哈夫曼编码的算法。
2.哈夫曼编码的算法实现
在构造哈夫曼树之后,求哈夫曼编码的主要思想是:依次以叶子为出发点,向上回溯至根结
点为止。回溯时走左分支则生成代码0,走右分支则生成代码 1。

Page 149
地址。
第5章树和二叉树
由于每个哈夫曼编码是变长编码,因此使用一个指针数组来存放每个字符编码串的首
//---- -哈夫曼编码表的存储表示
typedef char **HuffmanCode; // 动态分配数组存储哈夫曼编码表
各字符的哈夫曼编码存储在由 HuffmanCode 定义的动态分配的数组 HC中,为了实现方
便,数组的0号单元不使用,从1号单元开始使用,所以数组 HC 的大小为n+1,即编码表
HC 包括 n+1 行。但因为每个字符编码的长度事先不能确定,所以不能预先为每个字符分配大
小合适的存储空间。为不浪费存储空间,动态分配一个长度为n(字符编码长度一定小于n)
的一维数组 cd,用来临时存放当前正在求解的第i(1≤i≤n)个字符的编码,当第i个字符的
编码求解完毕后,根据数组 cd 的字符串长度分配 HC[i]的空间,然后将数组 cd中的编码复制
到 HC[i]中。
因为求解编码时是从哈夫曼树的叶子出发,向上回溯至根结点。所以对于每个字符,得到的
编码顺序是从右向左的,故将编码向数组 cd 存放的顺序也是从后向前的,即每个字符的第1个编
码存放在 cd[n-2]中(cd[n-1]存放字符串结束标志\0'),第2个编码存放在cd[n-3]中,依此类推,
直到全部编码存放完毕。
算法5.11 根据哈夫曼树求哈夫曼编码
【算法步骤】
48010
① 分配存储n个字符编码的编码表空间HC,长度为+1;分配临时存储每个字符编码的动
态数组空间 cd,cd[n-1]置为'\0'。
②逐个求解n个字符的编码,循环n次,执行以下操作:
● 设置变量 start 用于记录编码在cd中存放的位置,start 初始时指向最后,即编码结束
符位置 n-1;
设置变量用于记录从叶子结点向上回溯至根结点所经过的结点下标,c初始时为当
前待编码字符的下标i,f用于记录i的双亲结点的下标;
● 从叶子结点向上回溯至根结点,求得字符i的编码,当f没有到达根结点时,循环执
行以下操作:
回溯一次 start 向前指一个位置,即--start;
▶ 若结点c是f的左孩子,则生成代码0,否则生成代码1,生成的代码0或1保存
在 cd[start]中;
继续向上回溯,改变c和f的值。
政
根据数组 cd 的字符串长度为第i个字符编码分配空间 HC[i],然后将数组 cd 中的编码
复制到 HC[i]中。
③ 释放临时空间 cd。
【算法描述】
int n):
void CreatHuffmanCode (HuffmanTree HT,HuffmanCode &HC,int n)
{//从叶子到根逆向求每个字符的哈夫曼编码,存储在编码表 HC 中
HC=new char*[n+1];
cd=new char[n];
cd[n-1]='\0';
for(i=1;i<=n;++i)
品名: //分配存储n个字符编码的编码表空间
//分配临时存放每个字符编码的动态数组空间
//编码结束符
//逐个字符求哈夫曼编码
141

Page 150
142
数据结构(C语言版)(第2版)
start=n-1;
c=i;f=HT[i].parent;
while(f!=0)
{
//start 开始时指向最后,即编码结束符位置
//f指向结点c的双亲结点
//从叶子结点开始向上回溯,直到根结点
TU-start;
//回溯一次start 向前指一个位置
if(HT[f].lchild==c) cd[start]='0';
//结点cf的左孩子,则生成代码0
else cd[start]='1';
//结点c是f的右孩子,则生成代码1
c=f;f=HT[f].parent;
//继续向上回溯
//求出第i个字符的编码
( HC[i]=new char[n-start];
//为第i个字符编码分配空间
strcpy(HC[i], &cd[start]);
//将求得的编码从临时空间cd复制到HC的当前行中
//for
delete cd;
}
//释放临时空间
【例5.3】 已知某系统在通信联络中只可能出现8种字符,其概率分别为0.05,0.29,0.07,
0.08, 0.14,0.23, 0.03,0.11,试设计哈夫曼编码。
根据其出现的概率可设8个字符的权值为:w=(5,29,7,8,14,23,3,11),其对应的哈夫曼树如图5.28
所示。将树的左分支标记为0,右分支标记为1,便得到其哈夫曼编码表如图5.29 所示。
HC
1
0 1
1 0
234
1
0
1
1
1
0
1
1
1
1
5
1
1
0
67
0
0
0
1
1
1
8
0 1
0
图5.29 前缀编码表
3. 文件的编码和译码
(1)编码
有了字符集的哈夫曼编码表之后,对数据文件的编码过程是:依次读入文件中的字符c,在
哈夫曼编码表 HC中找到此字符,将字符c转换为编码表中存放的编码串。
(2)译码
对编码后的文件进行译码的过程必须借助于哈夫曼树。具体过程是:依次读入文件的二进制
码,从哈夫曼树的根结点(即HT[m])出发,若当前读入0,则走向左孩子,否则走向右孩子。
一旦到达某一叶子HT[i]时便译出相应的字符编码 HC[i]。然后重新从根出发继续译码,直至文件
结束。
具体编码和译码的算法留给读者去完成。

Page 151
第5章树和二叉树
5.8 案例分析与实现
在5.2节引入的案例5.1已在5.7节中进行了详细的讨论,案例5.2提出了可以利用二叉树来
表示表达式,本节将对案例5.2作进一步的分析,给出利用表达式构建表达式树和利用表达式树
求解表达式的算法。
案例 5.2:利用二叉树求解表达式的值。
【案例分析】
对于任意一个算术表达式,都可用二叉树来表示。表达式对应的二叉树创建后,利用二叉树
的遍历等操作,很容易实现表达式的求值运算。因此问题的关键就是如何创建表达式树,下面讨
论由中缀表达式创建表达式树的方法。
假设运算符均为双目运算符,则表达式对应的表达式树中叶子结点均为操作数,分支结点均
为运算符。由于创建的表达式树需要准确的表达运算次序,因此在扫描表达式创建表达式树的过
程中,当遇到运算符时不能直接创建结点,而应将其与前面的运算符进行优先级比较,根据比较
的结果再进行处理。这种处理方式类似于第3章的表达式求值算法中的运算符的比较,可以借助
一个运算符栈,来暂存已经扫描到的还未处理的运算符。
根据表达式树与表达式对应关系的递归定义,每两个操作数和一个运算符就可以建立一
棵表达式二叉树,而该二叉树又可以作为另一个运算符结点的一棵子树。可以另外借助一个
表达式树栈,来暂存已建立好的表达式树的根结点,以便其作为另一个运算符结点的子树而
被引用。
【案例实现】
为实现表达式树的创建算法,可以使用两个工作栈,一个称做OPTR,用以暂存运算符;另
一个称做 EXPT,用以暂存已建立好的表达式树的根结点。
为了便于实现,和第3章一样,假设每个表达式均以“#”开始,以“#”结束。
算法5.12 表达式树的创建
【算法步骤】
① 初始化 OPTR栈和EXPT栈,将表达式起始符“#”压入 OPTR 栈。
② 扫描表达式,读入第一个字符ch,如果表达式没有扫描完毕至“#”或OPTR 的栈顶元素
不为“#”时,则循环执行以下操作:国米米学个国甲大多
● 若ch不是运算符,则以ch为根创建一棵只有根结点的二叉树,且将该树根结点压入
EXPT栈,读入下一字符 ch;
● 若ch是运算符,则根据OPTR的栈顶元素和ch的优先级比较结果,做不同的处理:
若是小于,则ch压入OPTR栈,读入下一字符ch;
若是大于,则弹出 OPTR 栈顶的运算符,从EXPT 栈弹出两个表达式子树的根
结点,以该运算符为根结点,以EXPT 栈中弹出的第二个子树作为左子树,以
EXPT 栈中弹出的第一个子树作为右子树,创建一棵二叉树,并将该树根结点
压入EXPT栈;
若是等于,则 OPTR的栈顶元素是“(”且ch是“)”,这时弹出 OPTR栈顶的“(”,
相当于括号匹配成功,然后读入下一字符 ch。
143

Page 152
144
数据结构(C语言版)(第2版)
【算法描述】
void InitExpTree ()
{//表达式树的创建算法
InitStack (EXPT);
InitStack (OPTR);
Push (OPTR,'#');
cin>>ch;
while(ch!='#' | |GetTop (OPTR)!='#')
{
if(!In(ch))
{
}
else
CreateExpTree (T,NULL,NULL, ch);
Push (EXPT, T);
cin>>ch;
//初始化 EXPT 栈
//初始化 OPTR 栈
//将表达式起始符“#”压入OPTR栈
//表达式没有扫描完毕或OPTR的栈顶元素不为“#”
//ch不是运算符
//以ch 为根创建一棵只有根结点的二叉树
//将二叉树根结点T进EXPT栈
//读入下一字符
switch (Precede (GetTop (OPTR), ch))
//比较OPTR的栈顶元素和ch的优先级
{
case '<':
Push (OPTR, ch);cin>>ch;
break;
case '>':
Pop (OPTR, theta);
Pop (EXPT,b); Pop (EXPT,a);
CreateExpTree(T,a,b,theta)
//当前字符ch 压入OPTR栈,读入下一字符
//弹出 OPTR栈顶的运算符
//弹出 EXPT 栈顶的两个运算数
//以 theta 为根,a为左子树,b为右子树,创建一棵二叉树
Push (EXPT, T);
break;
case '='
Pop (OPTR,x);cin>>ch;
break;
}
//将二叉树根结点T进EXPT栈
//OPTR 的栈顶元素是“(”且ch是“)”
//弹出 OPTR 栈顶的“(”,读入下一字符 ch
//switch
【算法分析】
//while
此算法从头到尾扫描表达式中每个字符,若表达式的字符串长度为n,则此算法的时间复杂
度为O(n)。算法在运行时所占用的辅助空间主要取决于OPTR 栈和EXPT栈的大小,显然,它们
的空间大小之和不会超过n,所以此算法的空间复杂度也同样为O(n)。
算法5.13 表达式树的求值
【算法步骤】
① 设变量 Ivalue 和rvalue 分别用以记录表达式树中左子树和右子树的值,初始均为0。
② 如果当前结点为叶子结点为操作数),则返回该结点的数值,否则(结点为运算符)执
行以下操作:
递归计算左子树的值记为lvalue;
递归计算右子树的值记为rvalue;
● 根据当前结点运算符的类型,将lvalue 和 rvalue 进行相应运算并返回。